## コードレベルにおける重複
- 扱うデータの型は異なるが、似たような処理を行う2つのコードをどうリファクタリングするのか
- 継承を用いたAPI設計
    - 共有したいふるまいを抽出した新しい抽象クラスを作成し、それを継承した具象クラスでそれぞれのデータ型特有のコードを実装する
    - 継承を利用することで重複を排除しコードは保守しやすくなった。しかし一方で、密結合になった。    
    - ビジネス要件が変化して、特定の具象クラスにのみ変更を加える必要性が生まれると、この密結合部分のトレードオフが顕在化する
        - 他の具象クラスに影響を当てあることなく、抽象クラスの実装を変更することは不可能である
        - つまり、継承のトレードオフとして柔軟性が失われ、設計が大きく制限されていたということになる
    - この問題の解決策
        - instanceOf演算子を利用して、特定の具象クラスの場合に違うふるまいができるように実装を加えることができる
            - しかしこの解決策は脆弱で、親クラスと子クラスの間に密結合をもたらすことになる
                - 共通のふるまいを一般化するというそもそもの継承の目的に反している
                - ある1つの子クラスの詳細が共通の親クラスに漏れ出し、カプセル化が破綻している
        - コードの重複をあえて利用することで、この問題を緩和することができる    
            - しかし実際の現場では、再び継承を止めるという選択は多くの複雑なリファクタリングを伴うことが多い
        - 有力な代替手段として、継承によって動作の複数の側面を結合する代わりに独立した抽象化部品を構成する方法(Copositeパターン)がある
            - しかし、コードをメンテナンスする人が理解すべき抽象化部品の数が増加し、認知負荷が増える
            - つまり、どの解決策も長所と短所がある
    - 「選んだ手法によって得たい柔軟性」が、「別の方向に進化する可能性のある重複したコードを保守し続けること」よりも価値があるかを状況に応じて決める必要がある
        - ((設計のトレードオフを知識として知った上で、YAGNIをちゃんとやっていこうという理解))
- どのように重複を避けるかという議論は、そもそも「本物の重複」が存在することを前提にしている
    - 「本質的な重複」と「偶然の重複」に着目しよう
        - ソフトウェア開発者はパターンマッチングに過剰適合する傾向がある(本質と偶然を見極めずに共通化してしまう)
            - 2つのものが同一に見えていても、それらが同じビジネス目的を解決する、本質的な重複を意味しているとは限らない
            - 現在の要件では偶然同じように見えるが、将来的に変更され同等のものではなくなる可能性がある
                - これを最初に見分けることは難しい
        - 通常、2つの概念が異なることが判明したときに「分離」するよりも、概念が同じことに気づいたときに「共通化」する方が簡単である
            - 一度「共通化」を行い、複数の場所でそれが利用され始めるとコンポーネント間の結合が密になる
            - つまり安易に共通化をすることで、その後になって別のコンポーネントに「分離」するのが困難な状況を生み出している可能性がある
        - 独立したコンポーネントを作成し、多少コードの重複があってもしばらくの間独立させたまま実装を進めることができる
            - 時間を経てから共通のパターンが見え始めたときに抽象化をする。最初から重複を排除するのではなく、抽象化できたタイミングが重複を取り除くべきタイミング
            - 時として、重複したコードを残しておくことは、柔軟性が維持されチーム間の調整を減らす価値になる
        
        