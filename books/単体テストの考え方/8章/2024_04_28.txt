# 8章 統合(Integration)テストとは？
- 統合テストとは、以下の単体テストの性質を1つでも損なっているテストのことである
    - 1単位のふるまいを検証する
    - 実行時間が短い
    - 他のテストケースから隔離された状態で実行される
- 結合テストの目的は、システムがプロセス外依存と結合した状態で意図したように機能するのか、を検証すること
    - つまり、結合テストではコントローラに分類されるコードが検証されることになる(=ドメイン・モデルとプロセス外依存を結ぶコードを検証する)
    - 一方で、単体テストはドメイン・モデルを検証する
- ただし、コントローラに分類されるコードでも、単体テストになりうる
    - プロセス外依存をすべてモックに置き換えた場合はテストケース間で共有される依存がなくなって実行時間が早く、独立したテストが行えるため
    - しかしながら、モックに置き換えるべきでない依存も存在する
        - データベースがそれである。データベースは管理下にある依存のため最終的なテーブルの状態を検証するようにする。
        - 実際のデータベースを使った検証ができず、モックを使うのであれば、その結合テストは数行のコードを担保するのみでほとんど価値がない
- 取るに足らないコードと、過度に複雑なコードはテストされるべきではない
    - 前者に労力をかける価値はそもそもない
    - 後者は、テストの前にまずプロダクションコードのリファクタリングを行い、そのコードをドメイン・モデル(もしくはアルゴリズム)とコントローラに分けるべきである
        - すべてのテストケースにおいて検証対象となるのはドメイン・モデルかコントローラのどちらかだけである
        - ((ここで言っている「コントローラ(=プロセス外依存)」は広義の意味という理解。外部との対話層、CAのアダプタに当たる部分。))

## 単体テストと結合テストの数をうまく調整する
- 結合テストは、単体テストよりも多くのコードを実行させるので、退行に対する優れた保護が備わることになる
    - さらに、単体テストよりも実装の詳細から離れるためリファクタリングへの耐性も備わることになる
- しかし、結合テストは単体テストに比べてコストがかかるため、検証する数は単体テストよりも絞るべきである
    - 一般的に、単体テストは異常ケースをできるだけ多く検証する
    - 一方で、結合テストは1件のハッピー・パスと、単体テストでは検証できない異常ケースを検証するのが適切
        - 結合テストをつくるときはまず、"すべての"プロセス外依存とのやりとりを検証できるような長いハッピー・パスを見つける
    - ケースバイケースで、単純なアプリの場合はドメイン・モデルがコードに含まれず、単体テストと結合テストの数が同じになったり、まったく単体テストがない場合もある
    - ただし、非常に単純なアプリであっても、結合テストの価値が下がることはない。他のシステムと結合した状態を検証することが重要なのは変わらない。

## e2eテストを行うべきか
- e2eテストは必ずしも必要ない
    - e2eテストと結合テストの違いは、前者がテスト自体が外部クライアントとして検証するのに対し、後者はアプリをホストしているプロセスと同じプロセスでテストが実行されること
    - 結合テストにて、管理下にある依存をそのまま使い、管理下にない依存のみをモックに置き換えているのであれば、その結合テストはe2eテストと同等に近い保護を提供することになる
- しかしながら、動作確認として最長のハッピー・パスを経由するe2eテストがあることによるメリットはある
    - テスト対象のアプリがすべてのプロセス外依存と適切にやりとりできることを確信できるようになる
    - ((e2eテストが包括的な結合テストとしての役割を果たすので、どっちかで十分なイメージがあるけど、どちらもやる選択肢もアリなのか))

## インターフェイスを使った依存の抽象化
- なぜプロセス外依存にインターフェイスを使うのか？
    - 実装クラスが1つしかないのであれば、そのインターフェイスは抽象ではなく、導入しても疎結合になるわけではない
    - 実装クラスが1つなのにインターフェイスを使う理由は、モックをつくれるようにするためという実践的なもの
        - モックを使ってテスト対象とプロセス外依存とのあいだのやりとりを検証する
        - プロセス外依存をモックにする必要があるのは、管理下にない依存である場合のみである
    - つまり、インターフェイスを使うタイミングは以下の2つのパターンの場合である
        - インターフェイスに対して複数の実装クラスができるような本当の抽象化が行われるとき
        - 管理下にないプロセス外依存とのやりとりがあるとき

## 結合テストのベスト・プラクティス
- 結合テストを最大限に活用するための基本指針3つ
    - 1.ドメイン・モデルの境界を明確にする
        - ドメイン・モデル(開発によって解決しようとしている問題のドメイン知識)を配置する場所をわかりやすいところに用意する
            - そのコードが何を表現しているのかが明確になる
            - 加えてテストのしやすさが向上する
                - 単体テストがテスト対象とするのはドメイン・モデルとアルゴリズムなので、境界があることで単体テストのスコープが明確になるため
    - 2.アプリケーションを構成する層を減らす
        - コードの抽象化や汎用化を行う際にレイヤーが新たに増やしてしまうと何がどこにあり、何をしているのかが把握しづらくなる(認知不可増)
        - 各層を個別にテストする傾向が強くなり、各層にある少量のコードだけを実行する価値の低いテストをたくさん抱えることになる
        - バックエンドであれば、ドメイン層、アプリケーション・サービス層(コントローラなど)、インフラ層(ドメインに関係ない、プロセス外依存へのアクセス)の3つで十分
    - 3.循環依存を取り除く
        - 循環依存があるとコードを読む時にどこから始めるべきなのかが明確でなくなり認知不可が極端に高まる
        - テストにおいても、インターフェイスを使った循環依存の隠蔽が起こりやすくなる
- テストにとって効果的なプラクティスを実施することは、コードベース全体の健全性を改善することに繋がり、持続可能な開発の実現に通じる

## 1つのテストケースに含まれるフェーズは各種1つずつまで
- 1つのテストは、準備フェーズ、実行フェーズ、確認フェーズの3つを1つずつ含む
- 1つのテストに特定のフェーズが複数がある場合、そこには何らかの問題が潜んでいる可能性が高い
    - 1つのテストケースで複数のふるまいを検証しようとしてしまっている(テストの保守を困難にさせるアンチパターンの1つ)
    - 単一のふるまいのみをテスト対象とすることで、何を検証するのかが明確になり、必要に応じてテストケースを追加・変更しやすくなる
        - ただし、プロセス外依存を呼び出せる回数に制限がある場合など、開発者が好きにプロセス外依存を扱えない場合に限り例外的に許容される
